name: 'api-deployment'

concurrency: api-production

on:
  push:
    branches:
      - infra
    paths:
      - compose-service-api.yml

jobs:
  ec2:
    name: '🚀 AWS EC2'
    runs-on: [ self-hosted, production ]
    environment: api-production
    permissions:
      contents: read
      packages: read
    steps:
      - name: '⬇️ Checkout infra branch'
        uses: actions/checkout@v3
        with:
          ref: infra

      - name: '🔑 Login to Registry'
        uses: docker/login-action@v2.2.0
        with:
          registry: ${{ vars.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: '🗑️ Clean up stopped containers'
        run: docker compose rm --force

      - name: '🔎 Retrieve current running api'
        id: current
        run: echo "id=$(docker compose ps --all --quiet --status=running api)" >> $GITHUB_OUTPUT

      - name: '🚀 Deploy all services'
        if: steps.current.outputs.id == null
        env:
          spring_datasource_properties: ${{ secrets.SPRING_DATASOURCE_PROPERTIES }}
          tmdb_api_properties: ${{ secrets.TMDB_API_PROPERTIES }}
        run: docker compose up --wait --build --detach

      - name: '🚀 Deploy newly api service'
        if: steps.current.outputs.id != null
        id: newly
        env:
          spring_datasource_properties: ${{ secrets.SPRING_DATASOURCE_PROPERTIES }}
          tmdb_api_properties: ${{ secrets.TMDB_API_PROPERTIES }}
        run: docker compose up --wait --build --detach --remove-orphans --no-recreate --scale api=2 api

      - name: '🔄 Reload nginx'
        if: steps.newly.outcome == 'success'
        run: docker compose exec nginx nginx -s reload

      - name: '⏹️ Stop current version'
        if: steps.newly.outcome == 'success'
        env:
          current: ${{ steps.current.outputs.id }}
        run: docker stop --time 30 $current

      - name: '🖨️ Output Summary'
        if: ${{ always() }}
        run: |
          PIPE='|' LINE='---'
          table=$(docker ps -a --format "table {{.ID}}$PIPE{{.Names}}$PIPE{{.Image}}$PIPE{{.Ports}}$PIPE{{.Status}}")
          
          # Create table header line
          header_line=$LINE
          pipe_count=$(echo "$table" | head -n 1 | tr -cd $PIPE | wc -c)
          for _ in $(seq "$pipe_count"); do
            header_line+="|$LINE"
          done
          
          # Add a header line to second line
          table=$(echo "$table" | sed "2 s/^/$header_line\n/")

          echo "### Container Runs" >> $GITHUB_STEP_SUMMARY
          echo "$table" >> $GITHUB_STEP_SUMMARY
